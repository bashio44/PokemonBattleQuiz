<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ポケモン対戦クイズ</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="quiz-container" role="main" aria-labelledby="question">
    <div class="battle-grid" id="battleGrid">
      <div class="enemy-info" id="enemyInfo">
        <div id="enemyEV">努力値: ？？？</div>
        <div id="enemyNature">性格: ？？？</div>
        <div id="enemyItem">持ち物: ？？？</div>
      </div>

      <div class="enemy-icon" id="enemyIconWrap">
        <img id="enemyIcon" src="" alt="敵ポケモン">
      </div>

      <div class="enemy-namehp">
        <div class="name-label" id="enemyName">ポケモン名</div>
        <div class="hp-wrap"><div id="enemyHpBar" class="hp-bar"></div></div>
        <div id="enemyHpText" class="hp-text">100%</div>
      </div>

      <div class="ally-namehp">
        <div class="name-label" id="allyName">ポケモン名</div>
        <div class="hp-wrap"><div id="allyHpBar" class="hp-bar"></div></div>
        <div id="allyHpText" class="hp-text">100 / 100</div>
      </div>

      <div class="ally-icon-wrap">
        <img id="allyIcon" src="" alt="味方ポケモン">
      </div>

      <div class="ally-info" id="allyInfo">
        <div id="allyEV">努力値: 0</div>
        <div id="allyNature">性格: 無補正</div>
        <div id="allyItem">持ち物: なし</div>
      </div>

        <!-- 防御側HPバー表示領域 -->
        <div id="defenderHpArea" style="grid-column: 2 / 3; grid-row: 2 / 3; display:none; align-items:center; flex-direction:column; justify-content:center;">
          <div id="defenderHpBarWrap" style="width:100px; height:16px; background:#eee; border-radius:8px; overflow:hidden; margin-bottom:4px;">
            <div id="defenderHpBar" style="height:100%; background:#4caf50; width:100%; transition:width 0.3s;"></div>
          </div>
          <div id="defenderHpText" style="font-size:13px; text-align:center;"></div>
        </div>

      <div class="arrow-layer" aria-hidden="true">
        <svg class="arrow-svg" id="arrowSvg">
          <defs>
            <marker id="arrowHead" markerWidth="8" markerHeight="8" refX="6" refY="4" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L8,4 L0,8 z" fill="#333"></path>
            </marker>
          </defs>
          <line id="arrowLine" x1="0" y1="0" x2="0" y2="0" stroke="#333" stroke-width="3" stroke-linecap="round" marker-end="url(#arrowHead)"></line>
          <rect id="moveBg" x="0" y="0" rx="10" ry="10" width="180" height="36" class="move-bg"></rect>
          <text id="moveLabel" x="50%" y="50%" text-anchor="middle" fill="#111" font-size="18" font-weight="700">技名</text>
        </svg>
      </div>
    </div>

    <!-- 問題文は不要なので削除 -->
    <div id="answers" aria-live="polite"></div>
    <p id="result" aria-atomic="true"></p>
  </div>

  <script>
    // CSV読み込み
    async function loadCSV(url) {
      const res = await fetch(url);
      const text = await res.text();
      const lines = text.trim().split('\n');
      const header = lines[0].split(',');
      return lines.slice(1).map(line => {
        const values = line.split(',');
        const obj = {};
        header.forEach((h, i) => obj[h] = values[i]);
        return obj;
      });
    }

    const typeChart = {
      'ノーマル':   { 'いわ': 0.5, 'ゴースト': 0, 'はがね': 0.5 },
      'ほのお':     { 'くさ': 2, 'みず': 0.5, 'ほのお': 0.5, 'こおり': 2, 'むし': 2, 'いわ': 0.5, 'ドラゴン': 0.5, 'はがね': 2 },
      'みず':       { 'ほのお': 2, 'みず': 0.5, 'くさ': 0.5, 'じめん': 2, 'いわ': 2, 'ドラゴン': 0.5 },
      'でんき':     { 'みず': 2, 'でんき': 0.5, 'じめん': 0, 'ひこう': 2, 'くさ': 0.5, 'ドラゴン': 0.5 },
      'くさ':       { 'みず': 2, 'ほのお': 0.5, 'くさ': 0.5, 'じめん': 2, 'ひこう': 0.5, 'むし': 0.5, 'いわ': 2, 'ドラゴン': 0.5, 'はがね': 0.5 },
      'こおり':     { 'ほのお': 0.5, 'みず': 0.5, 'くさ': 2, 'じめん': 2, 'ひこう': 2, 'ドラゴン': 2, 'こおり': 0.5, 'はがね': 0.5 },
      'かくとう':   { 'ノーマル': 2, 'こおり': 2, 'いわ': 2, 'あく': 2, 'はがね': 2, 'ひこう': 0.5, 'エスパー': 0.5, 'むし': 0.5, 'ゴースト': 0, 'フェアリー': 0.5 },
      'どく':       { 'くさ': 2, 'どく': 0.5, 'じめん': 0.5, 'いわ': 0.5, 'ゴースト': 0.5, 'はがね': 0, 'フェアリー': 2 },
      'じめん':     { 'ほのお': 2, 'でんき': 2, 'くさ': 0.5, 'どく': 2, 'ひこう': 0, 'むし': 0.5, 'いわ': 2, 'はがね': 2 },
      'ひこう':     { 'くさ': 2, 'でんき': 0.5, 'ひこう': 0.5, 'むし': 2, 'いわ': 0.5, 'はがね': 0.5 },
      'エスパー':   { 'かくとう': 2, 'どく': 2, 'エスパー': 0.5, 'はがね': 0.5, 'あく': 0 },
      'むし':       { 'くさ': 2, 'ほのお': 0.5, 'かくとう': 0.5, 'どく': 0.5, 'ひこう': 0.5, 'エスパー': 2, 'ゴースト': 0.5, 'あく': 2, 'はがね': 0.5, 'フェアリー': 0.5 },
      'いわ':       { 'ほのお': 2, 'こおり': 2, 'かくとう': 0.5, 'じめん': 0.5, 'ひこう': 2, 'むし': 2, 'はがね': 0.5 },
      'ゴースト':   { 'ノーマル': 0, 'エスパー': 2, 'ゴースト': 2, 'あく': 0.5 },
      'ドラゴン':   { 'ドラゴン': 2, 'はがね': 0.5, 'フェアリー': 0 },
      'あく':       { 'エスパー': 2, 'かくとう': 0.5, 'あく': 0.5, 'フェアリー': 0.5 },
      'はがね':     { 'ほのお': 0.5, 'みず': 0.5, 'でんき': 0.5, 'こおり': 2, 'いわ': 2, 'はがね': 0.5, 'フェアリー': 2 },
      'フェアリー': { 'かくとう': 2, 'どく': 0.5, 'はがね': 0.5, 'ドラゴン': 2, 'あく': 2, 'フェアリー': 1 },
    };

    function getTypeEffectiveness(moveType, defenderTypes) {
      let eff = 1;
      defenderTypes.forEach(type => {
        if (!type) return;
        if (typeChart[moveType] && typeChart[moveType][type]) {
          eff *= typeChart[moveType][type];
        } else {
          eff *= 1;
        }
      });
      return eff;
    }

    function calcDamage({
      atkStat, defStat, movePower, moveType, defenderTypes, moveCategory = '物理',
      atkItem = '', defItem = ''
    }) {
      const level = 50;
      // atkStat / defStat は既に実数値（努力値・性格反映後）として渡される想定
      let atkStatAdj = atkStat;
      let defStatAdj = defStat;
      // アイテム効果（単純化）
      if (atkItem === 'こだわりハチマキ' && moveCategory === '物理') atkStatAdj = Math.floor(atkStatAdj * 1.5);
      if (atkItem === 'こだわりメガネ' && moveCategory === '特殊') atkStatAdj = Math.floor(atkStatAdj * 1.5);
      if (defItem === '突撃チョッキ' && moveCategory === '特殊') defStatAdj = Math.floor(defStatAdj * 1.5);
      const base = (((2 * level / 5 + 2) * movePower * atkStatAdj / defStatAdj) / 50) + 2;
      const effectiveness = getTypeEffectiveness(moveType, defenderTypes);
      return Math.floor(base * effectiveness);
    }

    // 実ステータスを計算するヘルパー
    function computeStat(base, ev = 0, level = 50, isHP = false, natureMult = 1.0) {
      const iv = 31; // 簡易的にIVは31固定
      const ev4 = Math.floor(ev / 4);
      if (isHP) {
        return Math.floor(((2 * base + iv + ev4) * level) / 100) + level + 10;
      } else {
        const tmp = Math.floor(((2 * base + iv + ev4) * level) / 100) + 5;
        return Math.floor(tmp * natureMult);
      }
    }

    let pokemonStats = [];
    let pokemonMoves = [];

    const questionEl = null; // 問題文不要のため null
    const answersEl = document.getElementById("answers");
    const resultEl = document.getElementById("result");
    const enemyIcon = document.getElementById("enemyIcon");
    const allyIcon = document.getElementById("allyIcon");
    const enemyNameEl = document.getElementById("enemyName");
    const enemyEVElem = document.getElementById("enemyEV");
    const enemyNatureEl = document.getElementById("enemyNature");
    const enemyItemEl = document.getElementById("enemyItem");
    const allyNameEl = document.getElementById("allyName");
    const allyEVElem = document.getElementById("allyEV");
    const allyNatureEl = document.getElementById("allyNature");
    const allyItemEl = document.getElementById("allyItem");
  const moveLabel = document.getElementById("moveLabel");
  const arrowLine = document.getElementById("arrowLine");
  const arrowSvg = document.getElementById("arrowSvg");
  const defenderHpArea = document.getElementById("defenderHpArea");
  const defenderHpBar = document.getElementById("defenderHpBar");
  const defenderHpText = document.getElementById("defenderHpText");
  const enemyHpBar = document.getElementById('enemyHpBar');
  const enemyHpText = document.getElementById('enemyHpText');
  const allyHpBar = document.getElementById('allyHpBar');
  const allyHpText = document.getElementById('allyHpText');

    let correctAnswer = null;
    let score = 0;
    let total = 0;

    function getRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

    function drawArrow(fromEl, toEl, moveName) {
      if (!fromEl || !toEl) return;
      // SVG coordinates relative to svg bbox
      const svgRect = arrowSvg.getBoundingClientRect();
      const aRect = fromEl.getBoundingClientRect();
      const bRect = toEl.getBoundingClientRect();
        // アイコンの中心から少し外側にずらす（被り防止）
        const offset = 48; // アイコン半径+α
        // from: アイコンの中心からto方向にoffsetだけ離す
        const dx = bRect.left + bRect.width / 2 - (aRect.left + aRect.width / 2);
        const dy = bRect.top + bRect.height / 2 - (aRect.top + aRect.height / 2);
        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
        const x1 = aRect.left + aRect.width / 2 - svgRect.left + (dx/dist)*offset;
        const y1 = aRect.top + aRect.height / 2 - svgRect.top + (dy/dist)*offset;
        const x2 = bRect.left + bRect.width / 2 - svgRect.left - (dx/dist)*offset;
        const y2 = bRect.top + bRect.height / 2 - svgRect.top - (dy/dist)*offset;
      arrowLine.setAttribute('x1', x1);
      arrowLine.setAttribute('y1', y1);
      arrowLine.setAttribute('x2', x2);
      arrowLine.setAttribute('y2', y2);
      moveLabel.textContent = moveName;
      // moveBg をテキスト幅に合わせる
      try {
        const bbox = moveLabel.getBBox();
        const pad = 16;
        const rect = document.getElementById('moveBg');
        rect.setAttribute('width', Math.max(80, bbox.width + pad));
        rect.setAttribute('x', bbox.x - pad/2);
        rect.setAttribute('y', bbox.y - 8);
      } catch (e) {
        // getBBox が失敗する環境では無視
      }
      // place moveLabel at midpoint
      const midX = (x1 + x2) / 2;
      const midY = (y1 + y2) / 2;
      moveLabel.setAttribute('x', midX);
      moveLabel.setAttribute('y', midY - 8); // 少し上に寄せる
    }

    function jpNatureLabel(n) {
      if (n === 'neutral') return '無補正';
      if (n === 'up') return '上昇';
      if (n === 'down') return '下降';
      return '無補正';
    }

    function generateQuiz() {
      if (!pokemonStats.length || !pokemonMoves.length) return;
      const attacker = getRandom(pokemonStats);
      const defender = getRandom(pokemonStats);
      const move = getRandom(pokemonMoves);

      let statKeyAtk = move["分類"] === "物理" ? "攻撃" : "特攻";
      let statKeyDef = move["分類"] === "物理" ? "防御" : "特防";
      const atkStat = Number(attacker[statKeyAtk]);
      const defStat = Number(defender[statKeyDef]);
      const movePower = Number(move["威力"]);
      const moveType = move["タイプ"];
      const defenderTypes = [defender["タイプ1"] || "ノーマル", defender["タイプ2"]].filter(Boolean);

      if (!movePower) return generateQuiz();

  // ランダム性格（簡易）と努力値・持ち物
  const natures = ['neutral','up','down'];
  const atkNature = getRandom(natures);
  const defNature = getRandom(natures);
  // 努力値は HP と 主な攻撃/防御に割り当てる（0 or 252 のランダム）
  const hpEVChoices = [0, 252];
  const atkStatEVChoices = [0, 252];
  const defStatEVChoices = [0, 252];
  const atkHpEV = hpEVChoices[Math.floor(Math.random() * hpEVChoices.length)];
  const atkOffEV = atkStatEVChoices[Math.floor(Math.random() * atkStatEVChoices.length)];
  const defHpEV = hpEVChoices[Math.floor(Math.random() * hpEVChoices.length)];
  const defDefEV = defStatEVChoices[Math.floor(Math.random() * defStatEVChoices.length)];
  const atkItems = ["", "こだわりハチマキ", "こだわりメガネ"];
  const defItems = ["", "突撃チョッキ"];
  const atkItem = atkItems[Math.floor(Math.random() * atkItems.length)];
  const defItem = defItems[Math.floor(Math.random() * defItems.length)];

      // 出題項目 (敵=当てる対象)
      const qTypes = ["atkEV", "atkItem", "defEV", "defItem"];
      const ask = qTypes[Math.floor(Math.random() * qTypes.length)];

      // 敵は「当てる対象」。ask が atk系なら attacker が敵、それ以外は defender が敵。
      const enemyIsAttacker = (ask === 'atkEV' || ask === 'atkItem');
      const enemy = enemyIsAttacker ? attacker : defender;
      const ally = enemyIsAttacker ? defender : attacker;

      // 表示用アイコン（固定配置：敵＝右上、味方＝左下）
      enemyIcon.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${Number(enemy["No"])}.png`;
      allyIcon.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${Number(ally["No"])}.png`;

      // 実数値を計算してダメージを算出（努力値・性格・アイテムを考慮）
      // 性格は簡易的に攻撃/防御どちらかに1.1/0.9を掛ける場合のみ適用する
      const natureTable = { 'up': 1.1, 'down': 0.9, 'neutral': 1.0 };
      const atkNatureMult = natureTable[atkNature] || 1.0;
      const defNatureMult = natureTable[defNature] || 1.0;

      // 攻撃側の種族値に対応するステータスキー
      const atkStatKey = (move["分類"] === "物理") ? '攻撃' : '特攻';
      const defStatKey = (move["分類"] === "物理") ? '防御' : '特防';

      // 実数値計算
      const atkReal = computeStat(Number(attacker[atkStatKey] || 1), atkOffEV, 50, false, atkNatureMult);
      const defReal = computeStat(Number(defender[defStatKey] || 1), defDefEV, 50, false, defNatureMult);
      const atkRealHP = computeStat(Number(attacker['HP'] || 20), atkHpEV, 50, true);
      const defRealHP = computeStat(Number(defender['HP'] || 20), defHpEV, 50, true);

      correctDamage = calcDamage({
        atkStat: atkReal, defStat: defReal, movePower, moveType, defenderTypes,
        moveCategory: move["分類"], atkItem, defItem
      });

  // 防御側（ダメージを受ける側）のHPを表示（種族値ではなく実数値を使用）
  const target = defender;
  const targetBaseHP = defRealHP; // 実数値
  const afterHp = Math.max(0, targetBaseHP - correctDamage);
  const afterRatio = Math.max(0, Math.min(1, afterHp / targetBaseHP));

      // 味方と敵それぞれのHPバーを同じ固定幅にリセット（見た目同サイズ）
      if (enemyHpBar && allyHpBar) {
        enemyHpBar.style.width = '100%';
        allyHpBar.style.width = '100%';
        enemyHpText.textContent = '100%';
        allyHpText.textContent = `100 / 100`;
      }

      // ダメージは target に当たるので該当バーをアニメーションで減らす
      setTimeout(() => {
        // defender 変数が現在の "enemy" オブジェクトと等しければ敵が被弾、
        // そうでなければ味方が被弾と判定して、それぞれのバーを減らす
        const defenderIsEnemy = (defender === enemy);
        if (defenderIsEnemy) {
          if (enemyHpBar) enemyHpBar.style.width = `${Math.round(afterRatio * 100)}%`;
          if (enemyHpText) enemyHpText.textContent = `${Math.round(afterRatio * 100)}%`;
        } else {
          if (allyHpBar) allyHpBar.style.width = `${Math.round(afterRatio * 100)}%`;
          if (allyHpText) allyHpText.textContent = `${Math.max(0, Math.round(afterHp))} / ${targetBaseHP}`;
        }
      }, 200);

      // 描画する情報（味方は全て表示、敵は不明箇所を ??? にする）
      // 努力値表記を組み立てる（例: H252 B0 または H0 D252）
      const enemyHpEvVal = (enemyIsAttacker ? atkHpEV : defHpEV);
      const enemyOffEvVal = (enemyIsAttacker ? atkOffEV : defDefEV);
      const enemyItemVal = (enemyIsAttacker ? atkItem : defItem);
      const enemyNatureVal = (enemyIsAttacker ? atkNature : defNature);

      const allyHpEvVal = (enemyIsAttacker ? defHpEV : atkHpEV);
      const allyOffEvVal = (enemyIsAttacker ? defDefEV : atkOffEV);
      const allyItemVal = (enemyIsAttacker ? defItem : atkItem);
      const allyNatureVal = (enemyIsAttacker ? defNature : atkNature);

      // 表示：敵（左上情報、右上アイコン）
      enemyNameEl.textContent = enemy["名前"];
      // 敵の努力値表示：HPと該当する攻防（攻撃側なら攻撃、被弾側なら防御系）を表記
      let enemyEvStr = '';
      if (enemyIsAttacker) {
        // 敵が攻撃側：表示は HP と攻撃系努力値（物理ならA、特殊ならC）
        if (move["分類"] === '物理') enemyEvStr = `H${enemyHpEvVal} A${enemyOffEvVal}`;
        else enemyEvStr = `H${enemyHpEvVal} C${enemyOffEvVal}`;
      } else {
        // 敵が被弾側：表示は HP と防御系努力値（物理ならB、特殊ならD）
        if (move["分類"] === '物理') enemyEvStr = `H${enemyHpEvVal} B${enemyOffEvVal}`;
        else enemyEvStr = `H${enemyHpEvVal} D${enemyOffEvVal}`;
      }
      const hideEnemyEv = ((ask === 'atkEV' && enemyIsAttacker) || (ask === 'defEV' && !enemyIsAttacker));
      enemyEVElem.textContent = '努力値: ' + (hideEnemyEv ? '？？？' : enemyEvStr);
      enemyNatureEl.textContent = '性格: ' + jpNatureLabel(enemyNatureVal);
      enemyItemEl.textContent = '持ち物: ' + ((ask === 'atkItem' && enemyIsAttacker) || (ask === 'defItem' && !enemyIsAttacker) ? '？？？' : (enemyItemVal || 'なし'));

      // 表示：味方（左下）
      allyNameEl.textContent = ally["名前"];
      // 味方のEV表示（敵と逆の割り当て）
      const allyHpEvValLocal = (enemyIsAttacker ? defHpEV : atkHpEV);
      const allyOffEvValLocal = (enemyIsAttacker ? defDefEV : atkOffEV);
      let allyEvStr = '';
      if (!enemyIsAttacker) {
        // 味方が攻撃側
        if (move["分類"] === '物理') allyEvStr = `H${allyHpEvValLocal} A${allyOffEvValLocal}`;
        else allyEvStr = `H${allyHpEvValLocal} C${allyOffEvValLocal}`;
      } else {
        // 味方が防御側
        if (move["分類"] === '物理') allyEvStr = `H${allyHpEvValLocal} B${allyOffEvValLocal}`;
        else allyEvStr = `H${allyHpEvValLocal} D${allyOffEvValLocal}`;
      }
      allyEVElem.textContent = '努力値: ' + String(allyEvStr);
      allyNatureEl.textContent = '性格: ' + jpNatureLabel(allyNatureVal);
      allyItemEl.textContent = '持ち物: ' + (allyItemVal || 'なし');

      // moveLabel を技名にセット（矢印に重ねる）
      moveLabel.textContent = move["技名"];

      // 選択肢と正誤設定（敵の不明箇所を当てる）
      let choices = [];
      if (ask === "atkEV" || ask === "defEV") {
        choices = [0, 252].map(String);
        // EV の正解は enemy の該当する攻/防側の EV（enemyOffEvVal）
        correctAnswer = String(enemyOffEvVal);
      } else if (ask === "atkItem") {
        choices = atkItems.map(v => v || "なし");
        correctAnswer = (enemyItemVal || "なし");
      } else if (ask === "defItem") {
        choices = defItems.map(v => v || "なし");
        correctAnswer = (enemyItemVal || "なし");
      }
      choices.sort(() => Math.random() - 0.5);

      answersEl.innerHTML = "";
      choices.forEach(answer => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = answer;
        btn.onclick = () => checkAnswer(answer);
        answersEl.appendChild(btn);
      });
      resultEl.textContent = "";

      // 矢印を描く（画像読み込み後に実行）
      const fromEl = (attacker === enemy) ? document.getElementById('enemyIcon') : document.getElementById('allyIcon');
      const toEl = (defender === enemy) ? document.getElementById('enemyIcon') : document.getElementById('allyIcon');

      function redraw() {
        drawArrow(fromEl, toEl, move["技名"]);
      }
      setTimeout(redraw, 80);
      enemyIcon.onload = redraw;
      allyIcon.onload = redraw;
    }

    function checkAnswer(answer) {
      total++;
      if (String(answer) === String(correctAnswer)) {
        score++;
        resultEl.textContent = "✅ 正解！";
        resultEl.style.color = "green";
      } else {
        resultEl.textContent = `❌ 不正解... 正解は ${correctAnswer}`;
        resultEl.style.color = "red";
      }
      setTimeout(generateQuiz, 1200);
    }

    // CSVロード後にクイズ開始
    Promise.all([
      loadCSV('pokemon_stats.csv'),
      loadCSV('pokemon_moves.csv')
    ]).then(([stats, moves]) => {
      pokemonStats = stats;
      pokemonMoves = moves;
      generateQuiz();
    }).catch(err => {
      console.error(err);
    });

  </script>
</body>
</html>

